**オブジェクトの生成に関するパターン**

- Abstract Factory：関連する部品(オブジェクト群)をまとめて一つのシステムを生成するための手順を抽象化。
オブジェクトの追加と変更が簡単にできる。

- Builder：操作と生成の分離を可能にしたパターン。元となる専用のクラスを用意し、複数のオブジェクトを生成できる。

- Factory Method：フレームワークの役割とオブジェクトを作成する役割の定義が可能。
インスタンス生成のための枠組みと、インスタンス生成のクラスを分離。クラスを増やし、機能を拡張する際に使用する。

- Prototype：原型方操作・処理を生成するようにするパターン。インスタンスをコピーして新しいインスタンスを作成(クローンの作成)ができる。
同じクラスで複数のオブジェクトを生成する際に作業を効率化

- Singleton；実態の中で唯一の生成を保証するパターン。1つのクラスから1つのインスタンスだけを生成するように制限する。




**プログラムの構造に関するパターン**

- Adaptor：本来関連のないクラス同士を関連付ける。
本来つながっていないコンピューターに動作や処理させるデータ同士を関連付け、「すでに提供されているもの」と「必要なもの」との間のズレを埋める。

- Bridge：機能を拡張するクラスと実装するクラスを分離し、その間の橋渡しを行い、別々にして拡張することを可能にする。
継承元のスーパークラスの抽象メソッドを適切に実装したり、サブクラスで機能を拡張する際に利用する。

- Composite：ファイルシステムの中にあるファイルとフォルダの中身をおなじものとみなすことができる。
フォルダ内のサブフォルダとファイルの関係のように再帰的な構造を作る際に利用する。

- Decorator：様々な組み合わせでのデコレーションや機能の追加ができる。

- Facade：複数のクラスを適切に制御するための「窓口」役のクラスを作成し、その「窓口」から各クラスへ指令を出す。
1つのメッセージで複数のことを処理してくれる。

- Flyweight：記載されている処理内容などを実体化することで、メモリやファイルなどプログラム以外を無駄なく使う役割があるパターン。
小さなオブジェクトを数多くロードする必要がある場合にインスタンスを可能な限り共有させて、無駄にインスタンスを作成せずに効率的に処理を行う。

- Proxy：「代理」に処理を肩代わりさせ、重い処理は必要な時点まで遅らせることが可能。
キー入力やマウス操作のメッセージに独自の処理が追加できるようになる。




**オブジェクトの振る舞いに関するパターン**

- Chain of Responsibility：責任の連鎖関係を構築するパターン。
あるクラスのオブジェクトが処理可能なら処理を行い、処理不可の場合は他のクラスのオブジェクトに送って処理を実行する。

- Command：データとメソッドを1つのオブジェクトのまとめる役割。
「マウスをクリック」「キーを押す」のような命令をインスタンスという「モノ」で管理する。

- Interpreter：プログラム言語を解析し、得られた結果の手順に基づき処理実行するパターン。
プログラムをミニ言語に分け、そのミニ言語を「通訳」するプログラムを作成。変更が必要な場合はミニ言語を書き換える。

- Iterator：複数のオブジェクトを順番に指し示し、オブジェクトの要素を反復処理をするパターン。

- Mediator：オブジェクト間の関係を調整する役割があるパターン。
「相談役」が複雑なオブジェクトの状態を把握し、適切な判断と支持を行う。

- Memento：コンピューターの操作・処理のデータの保存と復元を可能にするパターン。
インスタンスの状態を表す役割を設け、インスタンスの状態の保存と復元を行う。

- Observer：観察対象のオブジェクトから状態変化を通知するパターン。
if文を利用することなく、状態変化に対応した処理を実行

- State：モノではなく状態をクラスとして表現し、クラスを切り替えることで状態の変化を表す。

- Strategy：アルゴリズムの実装部分が交換可能で、変更を容易にする。

- Template Method：定型の記載機能を持っているパターン。
スーパークラスで処理の枠組みを定め、サブクラスでその具体的な内容を定義する。

- Visitor：操作を追加できるパターン。データ構造と処理を分離。